-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient (multi)linear algebra
--   
--   Library implements (multi)linear algebra based on multidimensional
--   indexed arrays - tensors. Quick tutorial is available here:
--   <a>Multilinear</a>
@package Multilinear
@version 0.8.0.0


-- | Generic tensor index which may be finitely- or infinitely-dimensional.
module Multilinear.Index

-- | Tensor index class which may be lower (covariant), upper
--   (contravariant) or indifferent.
class Index i where i1 !=! i2 = equivI i1 i2

-- | Index name
indexName :: Index i => i -> String

-- | Returns True if index is lower (covariant), False otherwise.
isCovariant :: Index i => i -> Bool

-- | Returns True if index is upper (contravariant), False otherwise.
isContravariant :: Index i => i -> Bool

-- | Returns True if index if indifferent, False otherwise.
isIndifferent :: Index i => i -> Bool

-- | Returns True if two indices are equivalent, thus differs only by name,
--   but share same size and type.
equivI :: Index i => i -> i -> Bool

-- | Infix equivalent for <tt>equiv</tt>. Has low priority equal to 2.
(!=!) :: Index i => i -> i -> Bool

-- | Convert to generic index type
toTIndex :: Index i => i -> TIndex

-- | Generic index type finitely- or infinitely-dimensional
data TIndex
Covariant :: Maybe Int -> String -> TIndex
[indexSize] :: TIndex -> Maybe Int
[tIndexName] :: TIndex -> String
Contravariant :: Maybe Int -> String -> TIndex
[indexSize] :: TIndex -> Maybe Int
[tIndexName] :: TIndex -> String
Indifferent :: Maybe Int -> String -> TIndex
[indexSize] :: TIndex -> Maybe Int
[tIndexName] :: TIndex -> String
instance GHC.Generics.Generic Multilinear.Index.TIndex
instance GHC.Classes.Eq Multilinear.Index.TIndex
instance GHC.Show.Show Multilinear.Index.TIndex
instance Multilinear.Index.Index Multilinear.Index.TIndex
instance Data.Serialize.Serialize Multilinear.Index.TIndex
instance Data.Aeson.Types.FromJSON.FromJSON Multilinear.Index.TIndex
instance Data.Aeson.Types.ToJSON.ToJSON Multilinear.Index.TIndex
instance Control.DeepSeq.NFData Multilinear.Index.TIndex
instance GHC.Classes.Ord Multilinear.Index.TIndex
instance Data.Hashable.Class.Hashable Multilinear.Index.TIndex


-- | Finite-dimensional tensor index.
module Multilinear.Index.Finite

-- | Index of finite-dimensional tensor with specified size
data Index
Covariant :: Int -> String -> Index
[indexSize] :: Index -> Int
[indexName'] :: Index -> String
Contravariant :: Int -> String -> Index
[indexSize] :: Index -> Int
[indexName'] :: Index -> String
Indifferent :: Int -> String -> Index
[indexSize] :: Index -> Int
[indexName'] :: Index -> String
instance GHC.Generics.Generic Multilinear.Index.Finite.Index
instance GHC.Classes.Eq Multilinear.Index.Finite.Index
instance GHC.Show.Show Multilinear.Index.Finite.Index
instance Multilinear.Index.Index Multilinear.Index.Finite.Index
instance Data.Serialize.Serialize Multilinear.Index.Finite.Index
instance Data.Aeson.Types.FromJSON.FromJSON Multilinear.Index.Finite.Index
instance Data.Aeson.Types.ToJSON.ToJSON Multilinear.Index.Finite.Index
instance Control.DeepSeq.NFData Multilinear.Index.Finite.Index
instance GHC.Classes.Ord Multilinear.Index.Finite.Index
instance Data.Hashable.Class.Hashable Multilinear.Index.Finite.Index


-- | Infinite-dimensional tensor index.
module Multilinear.Index.Infinite

-- | Index of infinite-dimensional tensor
data Index
Covariant :: String -> Index
[indexName'] :: Index -> String
Contravariant :: String -> Index
[indexName'] :: Index -> String
Indifferent :: String -> Index
[indexName'] :: Index -> String
instance GHC.Generics.Generic Multilinear.Index.Infinite.Index
instance GHC.Classes.Eq Multilinear.Index.Infinite.Index
instance GHC.Show.Show Multilinear.Index.Infinite.Index
instance Multilinear.Index.Index Multilinear.Index.Infinite.Index
instance Data.Serialize.Serialize Multilinear.Index.Infinite.Index
instance Data.Aeson.Types.FromJSON.FromJSON Multilinear.Index.Infinite.Index
instance Data.Aeson.Types.ToJSON.ToJSON Multilinear.Index.Infinite.Index
instance Control.DeepSeq.NFData Multilinear.Index.Infinite.Index
instance GHC.Classes.Ord Multilinear.Index.Infinite.Index
instance Data.Hashable.Class.Hashable Multilinear.Index.Infinite.Index


-- | Multilinear library provides efficient and terse way to deal with
--   linear algebra in Haskell. It is based on concept of tensor - a
--   multidimensional indexed array of numbers. Vectors, matrices and
--   linear functionals are examples of low-order tensors.
--   
--   <h1>Quick tutorial</h1>
--   
--   Tensors are indexed, each having one or several indices numbering its
--   components. A scalar has no indices, as being simply a value. A vector
--   has one index, because it is a one-dimensional list of numbers. A
--   matrix has two indices, being a bidimensional table of numbers.
--   Tensors are arbitrarily - dimensional, so you can have a vector of
--   matrices (third-order tensor) and so on. Such tensors are especially
--   useful when dealing with more complex task, such as programming neural
--   networks e.g. for deep learning.
--   
--   Index may be either <b>lower (contravariant)</b> or <b>upper
--   (covariant)</b>, depending on its function.
--   
--   A vector has one <b>upper</b> or <b>contravariant</b> index, because
--   it represents a value, point in a space. A linear functional (called
--   in this library as a <b>form</b>) is represented as a list of numbers,
--   similar to vector, but it does not indicate a value, but rather a
--   coefficients of <b>linear map</b> or <b>transformation</b> that takes
--   a vector and returns a number, simply by calculating a linear
--   combination of vector components with weights being a linear
--   functional coefficients. So elements of linear functional are indexed
--   by <b>lower</b> or <b>covariant</b> index.
--   
--   A matrix also represents a linear transformation, similar to linear
--   functional, but it take a vector and return a vector, not a scalar. So
--   matrix is simply a bunch of linear functionals - each one is a matrix
--   row and returns a one element of resulting vector. These linear
--   functionals are also indexed - of course by an contravariant index, as
--   vector, which is returned by a matrix. So matrix is a tensor with two
--   indices - one uppper (contravariant) and one lower (covariant).
--   
--   A dot product is - what a surprise! - a linear transformation. But it
--   is different from matrix - it takes two vectors to multiplicate and
--   returns one number. So it needs two lower (covariant) indices. In
--   fact, a dot product is represented as a bidimensional table of numbers
--   - as matrix - but with two lower indices, instead of one upper and one
--   lower. Tensors with several lower indices are called n-forms.
--   Actually, many linear maps that takes two vectors and returns a number
--   are represented in such notation. A dot product is a table filled with
--   zeros but having a 1-s in diagonal of the table - it look visually
--   identical like unit matrix, but it isn't a matrix - it's actually a
--   2-form. In this library dot product is called (as in abstract maths) a
--   <b>Kronecker delta</b> (in <a>Multilinear.NForm</a>").
--   
--   A cross product takes two vectors and returns a vector of numbers. So,
--   as you can guess, it has three indices - two covariant (lower) and one
--   upper (contravariant). A tensor that corresponds to cross product is
--   called Levi-Civita symbol and is implemented under
--   <a>Multilinear.Tensor</a>.
--   
--   As you see, multidimensional indexed arrays - tensors - provide a
--   unified way to deal with linear algebra - such with data (vectors) and
--   functions operating on them (matrices, n-forms). Using tensors instead
--   of limited number of pre-defined functions, you gain a power of
--   universal formalism, where you can express any linear function you
--   want to deal with.
--   
--   When you apply a linear functional to a vector, you compute a linear
--   combination - or a weighted sum - of its components. It is so common
--   operation in linear algebra, that it requires a convenient way to
--   note. Einstein (1905) introduced a summation rule:
--   
--   If you multiply a tensor with lower index <b><i>i</i></b> by a tensor
--   with upper index with same name <b>/i</b> then the linear combination
--   of its components is automatically computed. The only condition is
--   that an index of vector and index of corresponding linear
--   transformation must have the same name.
--   
--   <h2>Examples</h2>
--   
--   <pre>
--   &gt;&gt;&gt; v = Vector.fromIndices "i" 5 $ \i -&gt; i + 2 (vector v has 5 elements and v[i] = i + 2, indexing from 0)
--   &gt;&gt;&gt; v
--   &lt;i:5&gt;
--      | 2
--      | 3
--      | 4
--      | 5
--      | 6
--   &gt;&gt;&gt; f = Form.const "i" 5 1 (linear functional has 5 elements and f[i] = 1)
--   &gt;&gt;&gt; f
--   [i:5] [1,1,1,1,1]
--   &gt;&gt;&gt; f * v
--   20
--   </pre>
--   
--   If you want to apply a vector to matrix, you must simply multiply
--   them. The only condition is - as you can guess - that lower
--   (indicating that matrix is a linear transformation) index of matrix
--   must have the same name as the upper index of vector (indicating that
--   this vector is a argument of matrix linear transformation; an upper
--   index of matrix here indicates that this linear transformation returns
--   a vector)
--   
--   <pre>
--   &gt;&gt;&gt; m = Matrix.fromIndices "ij" 5 5 $ \i j -&gt; i + j
--   &gt;&gt;&gt; m
--   &lt;i:5&gt;
--      | [j:5] [0,1,2,3,4]
--      | [j:5] [1,2,3,4,5]
--      | [j:5] [2,3,4,5,6]
--      | [j:5] [3,4,5,6,7]
--      | [j:5] [4,5,6,7,8]
--   &gt;&gt;&gt; v = Vector.fromIndices "j" 5 $ \j -&gt; j (vector v has 5 elements and v[j] = j, indexing from 0)
--   &gt;&gt;&gt; v
--   &lt;j:5&gt;
--      | 0
--      | 1
--      | 2
--      | 3
--      | 4
--   &gt;&gt;&gt; m * v
--   &lt;i:5&gt;
--      | 30
--      | 40
--      | 50
--      | 60
--      | 70
--   </pre>
--   
--   Note, that result vector is indexed with "i" - the same index as
--   uppper index of our matrix.
--   
--   If you want to do a matrix multiplication, a lower index of first
--   matrix must have the same name as upper index of second matrix.
--   
--   <pre>
--   &gt;&gt;&gt; m1 = Matrix.fromIndices "ij" 3 5 $ \i j -&gt; i + j
--   &gt;&gt;&gt; m1
--   &lt;i:3&gt;
--      | [j:5] [0,1,2,3,4]
--      | [j:5] [1,2,3,4,5]
--      | [j:5] [2,3,4,5,6]
--   &gt;&gt;&gt; m2 = Matrix.fromIndices "jk" 5 4 $ \j -&gt; i + j (vector v has 5 elements and v[j] = j, indexing from 0)
--   &gt;&gt;&gt; m2
--   &lt;j:5&gt;
--      | [k:4] [0,1,2,3]
--      | [k:4] [1,2,3,4]
--      | [k:4] [2,3,4,5]
--      | [k:4] [3,4,5,6]
--      | [k:4] [4,5,6,7]
--   &gt;&gt;&gt; m1 * m2
--   &lt;i:3&gt;
--      | [k:4] [30,40,50,60]
--      | [k:4] [40,50,60,70]
--      | [k:4] [50,60,70,80]
--   </pre>
--   
--   Note, that rule that first matrix lower index must be the same as the
--   second matrix upper index corresponeds to the fact, that to multiply
--   two matrices, the widht of first matrix must be the same as width of
--   the second matrix. The rule of matrix multiplication guarantees, that
--   this operation is equivalent to linear functions composition.
--   
--   The dot product of vectors may be done by simply making one of vectors
--   with lower index, or - more correctly - by applying two vectors to
--   Kronecker delta:
--   
--   <pre>
--   &gt;&gt;&gt; v1 = Vector.fromIndices "i" 5 $ \i -&gt; i + 2 (vector v has 5 elements and v[i] = i + 2, indexing from 0)
--   &gt;&gt;&gt; v1
--   &lt;i:5&gt;
--      | 2
--      | 3
--      | 4
--      | 5
--      | 6
--   &gt;&gt;&gt; v2 = Vector.fromIndices "j" 5 $ \j -&gt; j (vector v has 5 elements and v[j] = j, indexing from 0)
--   &gt;&gt;&gt; v2
--   &lt;j:5&gt;
--      | 0
--      | 1
--      | 2
--      | 3
--      | 4
--   &gt;&gt;&gt; v1 * (lower "j" v2)
--   50
--   &gt;&gt;&gt; NForm.dot 5 "ij" * v1 * v2 (A Kronecker delta - representing a dot product - of size 5 with indices "i" and "j" is multiplied by v1 and v2)
--   50
--   </pre>
--   
--   If you want to know more about linear algebra and Einstein convention,
--   read Wikipedia:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Matrix_(mathematics)</a></li>
--   
--   <li><a>https://en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors</a></li>
--   <li><a>https://en.wikipedia.org/wiki/Einstein_notation</a></li>
--   </ul>
module Multilinear

-- | Multidimensional array treated as multilinear map - tensor
class (Num (t a), Monoid (t a), Functor t) => Multilinear t a where indicesNames t = indexName <$> indices t equiv t1 t2 = fromList (indices t1) == fromList (indices t2) t1 |==| t2 = equiv t1 t2 raise t i = t /\ i t /\ i = raise t i lower t i = t \/ i t \/ i = lower t i shiftRight t n | isJust $ successor n (indicesNames t) = shiftLeft t (fromJust $ successor n (indicesNames t)) | otherwise = t where successor x (a1 : a2 : as) = if x == a1 then Just a2 else successor x (a2 : as) successor _ _ = Nothing t |>> n = shiftRight t n shiftRightmost t n = until (\ x -> n == last (indicesNames x)) (|>> n) t t |>>> n = shiftRightmost t n shiftLeft t n | isJust (predecessor n (indicesNames t)) = shiftRight t (fromJust $ predecessor n (indicesNames t)) | otherwise = t where predecessor x (a1 : a2 : as) = if x == a2 then Just a1 else predecessor x (a2 : as) predecessor _ _ = Nothing t <<| n = shiftLeft t n shiftLeftmost t n = until (\ x -> n == head (indicesNames x)) (<<| n) t t <<<| n = shiftLeftmost t n map = fmap

-- | Add scalar <tt>a</tt> to each element of tensor <tt>t</tt>
(+.) :: Multilinear t a => a -> t a -> t a

-- | Subtract each element of tensor <tt>t</tt> from scalar scalar left
(-.) :: Multilinear t a => a -> t a -> t a

-- | Multiply scalar <tt>a</tt> by each element of tensor <tt>t</tt>
(*.) :: Multilinear t a => a -> t a -> t a

-- | Add each element of tensor <tt>t</tt> to scalar <tt>a</tt>
(.+) :: Multilinear t a => t a -> a -> t a

-- | Subtract scalar <tt>a</tt> from each element of tensor <tt>t</tt>
(.-) :: Multilinear t a => t a -> a -> t a

-- | Multiply each element of tensor <tt>t</tt> by scalar <tt>a</tt>
(.*) :: Multilinear t a => t a -> a -> t a

-- | Tensor adding - functionally equal to Num (+) but more efficient
(.+.) :: Multilinear t a => t a -> t a -> t a

-- | Tensor subtracting - functionally equal to Num (-) but more efficient
(.-.) :: Multilinear t a => t a -> t a -> t a

-- | Tensor multiplication - functionally equal to Num (*) but more
--   efficient
(.*.) :: Multilinear t a => t a -> t a -> t a

-- | List of all tensor indices
indices :: Multilinear t a => t a -> [TIndex]

-- | List of tensor indices names
indicesNames :: Multilinear t a => t a -> [String]

-- | Tensor order - number of covariant and contravariant indices
--   
--   <tt>order t = (cv, cov)</tt> where <tt>cv</tt> is number of upper and
--   <tt>cov</tt> is number of lower indices
order :: Multilinear t a => t a -> (Int, Int)

-- | Return size of index with given name of Nothing if index is
--   infinite-dimensional
size :: Multilinear t a => t a -> String -> Either String Int

-- | Check if tensors are equivalent (have same indices but in different
--   order)
equiv :: Multilinear t a => t a -> t a -> Bool

-- | Infix equivalent of <a>equiv</a>. Has low priority equal to 1. |
(|==|) :: Multilinear t a => t a -> t a -> Bool

-- | <tt>t $| "ij" "kl"</tt> renames upper indices of tensor <tt>t</tt> to
--   <tt>ij</tt> and lower indices to <tt>kl</tt>
($|) :: Multilinear t a => t a -> (String, String) -> t a

-- | <tt>raise t "i"</tt> raises an index <tt>i</tt> of tensor <tt>t</tt>
raise :: Multilinear t a => t a -> String -> t a

-- | Infix equivalent of <a>raise</a>
(/\) :: Multilinear t a => t a -> String -> t a

-- | <tt>lower t "i"</tt> lowers an index <tt>i</tt> of tensor <tt>t</tt>
lower :: Multilinear t a => t a -> String -> t a

-- | Infix equivalent of <a>lower</a>
(\/) :: Multilinear t a => t a -> String -> t a

-- | Switch all indices of tensor <tt>t</tt> - upper indices becomes lower
--   and vice versa
transpose :: Multilinear t a => t a -> t a

-- | Shift tensor index right
--   
--   <tt>shiftRight t "i"</tt> moves index <tt>i</tt> of tensor <tt>t</tt>
--   one level depeer in recursion. Elements of tensor as indexed with
--   indices names becomes unchanged.
--   
--   Right shift of an index is equivalent to left shift of its successor
--   in recursion <tt>s</tt>, if only <tt>s</tt> exists, so: Given a tensor
--   <tt>t[i1,i2,i3,...]</tt>: <tt>shiftRight t "i2" == t[i1,i3,i2,...] ==
--   shiftLeft t "i3"</tt>
shiftRight :: Multilinear t a => t a -> String -> t a

-- | Infix equivalent of <a>shiftRight</a>
--   
--   <tt>t |&gt;&gt; "i"</tt> moves index <tt>i</tt> of tensor <tt>t</tt>
--   one level depeer in recursion
(|>>) :: Multilinear t a => t a -> String -> t a

-- | Shift tensor index rightmost
--   
--   <tt>shiftRightmost t "i"</tt> moves index <tt>i</tt> of tensor
--   <tt>t</tt> to the deepest level in recursion. Elements of tensor as
--   indexed with indices names becomes unchanged.
shiftRightmost :: Multilinear t a => t a -> String -> t a

-- | Infix equivalent of <a>shiftRightmost</a>
--   
--   <tt>t |&gt;&gt;&gt; "i"</tt> moves index <tt>i</tt> of tensor
--   <tt>t</tt> to the deepest level in recursion
(|>>>) :: Multilinear t a => t a -> String -> t a

-- | Shift tensor index left. Elements of tensor as indexed with indices
--   names becomes unchanged.
--   
--   <tt>shiftLeft t "i"</tt> moves index <tt>i</tt> of tensor <tt>t</tt>
--   one level up in recursion
--   
--   Left shift of an index is equivalent to right shift of its predecessor
--   in recursion <tt>p</tt>, if only <tt>p</tt> exists, so: Given a tensor
--   t[i1,i2,i3,...]: <tt>shiftLeft t "i3" == t[i1,i3,i2,...] == shiftRight
--   t "i2"</tt>
shiftLeft :: Multilinear t a => t a -> String -> t a

-- | Infix equivalent to <a>shiftLeft</a>
--   
--   <tt>t &lt;&lt;| "i"</tt> moves index <tt>i</tt> of tensor <tt>t</tt>
--   one level up in recursion
(<<|) :: Multilinear t a => t a -> String -> t a

-- | Shift tensor index leftmost. Elements of tensor as indexed with
--   indices names becomes unchanged.
--   
--   <tt>shiftLeftmost t "i"</tt> moves index <tt>i</tt> of tensor
--   <tt>t</tt> to the first level in recursion
shiftLeftmost :: Multilinear t a => t a -> String -> t a

-- | Infix equivalent of <a>shiftLeftmost</a>
--   
--   <tt>t &lt;&lt;&lt;| "i"</tt> moves index <tt>i</tt> of tensor
--   <tt>t</tt> to the first level in recursion
(<<<|) :: Multilinear t a => t a -> String -> t a

-- | Concatenation of two tensors by common index
--   
--   Tensors must be equivalent: <a>equiv</a> t1 t2 == True
augment :: Multilinear t a => t a -> t a -> String -> t a

-- | Simple mapping
--   
--   <tt>map f t</tt> returns tensor <tt>t2</tt> in which <tt>t2[i1,i2,...]
--   = f t[i1,i2,...]</tt>
map :: Multilinear t a => (a -> b) -> t a -> t b

-- | Serialize to binary string
toBinary :: (Multilinear t a, Serialize a) => t a -> ByteString

-- | Write to binary file. Uses compression with gzip
toBinaryFile :: (Multilinear t a, Serialize a) => String -> t a -> IO ()

-- | Deserialize from binary string
fromBinary :: (Multilinear t a, Serialize a) => ByteString -> Either String (t a)

-- | Read from binary file
fromBinaryFile :: (Multilinear t a, Serialize a) => String -> EitherT String IO (t a)

-- | Serialize to JSON string
toJSON :: (Multilinear t a, ToJSON a) => t a -> ByteString

-- | Write to JSON file
toJSONFile :: (Multilinear t a, ToJSON a) => String -> t a -> IO ()

-- | Deserialize from JSON string
fromJSON :: (Multilinear t a, FromJSON a) => ByteString -> Maybe (t a)

-- | Read from JSON file
fromJSONFile :: (Multilinear t a, FromJSON a) => String -> MaybeT IO (t a)

-- | If container on which tensor instance is built, allows for random
--   access of its elements, then the tensor can be instanced as Accessible
class Multilinear t a => Accessible t a

-- | Accessing tensor elements
--   
--   <tt>el ["i","j"] t [4,5]</tt> returns all tensor elements which index
--   <tt>i</tt> is equal to 4 and index <tt>j</tt> is equal to 5. Values of
--   other indices are insignificant
--   
--   If given index value is out of range, then modulo operation is
--   performed: el ["i","j"] t [40 50] = t[40 mod size i, 50 mod size j]
el :: Accessible t a => [String] -> t a -> [Int] -> t a

-- | Mapping with indices - mapping function takes not only a tensor
--   element value but also its indices in tensor
--   
--   <tt>iMap f t</tt> return tensor <tt>t2</tt> in which <tt>t2[i1,i2,...]
--   = f [i1,i2,...] t[i1,i2,...]</tt>
iMap :: Accessible t a => ([Int] -> a -> b) -> t a -> t b
class StandardTensor t c a where type TensorIndex t c a where {
    type family TensorIndex t c a;
}
scalar :: StandardTensor t c a => a -> t c a
simple :: StandardTensor t c a => TensorIndex t c a -> c a -> t c a
tensor :: StandardTensor t c a => TensorIndex t c a -> c (t c a) -> t c a


-- | <ul>
--   <li>This module contains generic implementation of tensor defined as
--   nested arrays</li>
--   </ul>
module Multilinear.Generic

-- | Tensor defined recursively as scalar or list of other tensors
--   
--   <tt>c</tt> is type of a container, <tt>i</tt> is type of index size
--   and <tt>a</tt> is type of tensor elements
data Tensor a

-- | Scalar
Scalar :: a -> Tensor a

-- | value of scalar
[scalarVal] :: Tensor a -> a

-- | Simple, one-dimensional finite tensor
SimpleFinite :: Index -> Vector a -> Tensor a

-- | Finite index <a>Mutltilinear.Index.Finite</a> of tensor
[tensorFiniteIndex] :: Tensor a -> Index
[tensorScalars] :: Tensor a -> Vector a

-- | Finite array of other tensors
FiniteTensor :: Index -> Vector (Tensor a) -> Tensor a

-- | Finite index <a>Mutltilinear.Index.Finite</a> of tensor
[tensorFiniteIndex] :: Tensor a -> Index

-- | Array of tensors on deeper recursion level
[tensorsFinite] :: Tensor a -> Vector (Tensor a)

-- | Infinite list of other tensors
InfiniteTensor :: Index -> [Tensor a] -> Tensor a

-- | Infinite index <a>Mutltilinear.Index.Infinite</a> of tensor
[tensorInfiniteIndex] :: Tensor a -> Index

-- | Infinite list of tensors on deeper recursion level
[tensorsInfinite] :: Tensor a -> [Tensor a]

-- | Operations on tensors may throw an error
Err :: String -> Tensor a

-- | Error message
[errMessage] :: Tensor a -> String

-- | Recursive indexing on list tensor <tt>t ! i = t[i]</tt>
(!) :: Tensor a -> Int -> Tensor a

-- | Merge FiniteTensor of Scalars to SimpleFinite tensor for performance
--   improvement
mergeScalars :: Tensor a -> Tensor a

-- | Return true if tensor is a scalar
isScalar :: Tensor a -> Bool

-- | Return true if tensor is a simple tensor
isSimple :: Tensor a -> Bool

-- | Return True if tensor is a complex tensor
isFiniteTensor :: Tensor a -> Bool

-- | Return True if tensor is a infinite tensor
isInfiniteTensor :: Tensor a -> Bool
dot :: Num a => Tensor a -> Tensor a -> Tensor a

-- | Apply a tensor operator elem by elem and merge scalars to simple
--   tensor at the and
_elemByElem :: Num a => Tensor a -> Tensor a -> (a -> a -> a) -> (Tensor a -> Tensor a -> Tensor a) -> Tensor a
contractionErr :: TIndex -> TIndex -> Tensor a

-- | Return generic tensor index
tensorIndex :: Tensor a -> TIndex
instance GHC.Generics.Generic (Multilinear.Generic.Tensor a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Multilinear.Generic.Tensor a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Multilinear.Generic.Tensor a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Multilinear.Generic.Tensor a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Multilinear.Generic.Tensor a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Multilinear.Generic.Tensor a)
instance (GHC.Show.Show a, GHC.Num.Num a) => GHC.Show.Show (Multilinear.Generic.Tensor a)
instance GHC.Base.Functor Multilinear.Generic.Tensor
instance GHC.Classes.Ord a => GHC.Classes.Ord (Multilinear.Generic.Tensor a)
instance GHC.Num.Num a => GHC.Base.Monoid (Multilinear.Generic.Tensor a)
instance GHC.Num.Num a => GHC.Num.Num (Multilinear.Generic.Tensor a)
instance (GHC.Num.Num a, Data.Bits.Bits a) => Data.Bits.Bits (Multilinear.Generic.Tensor a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Multilinear.Generic.Tensor a)
instance GHC.Float.Floating a => GHC.Float.Floating (Multilinear.Generic.Tensor a)
instance GHC.Num.Num a => Multilinear.Multilinear Multilinear.Generic.Tensor a
instance GHC.Num.Num a => Multilinear.Accessible Multilinear.Generic.Tensor a


-- | <ul>
--   <li>This module provides convenient constructors that generate a
--   arbitrary finitely- or infinitely-dimensional tensors.</li>
--   <li>Finitely-dimensional tensors provide much greater performance than
--   inifitely-dimensional</li>
--   </ul>
module Multilinear.Tensor

-- | Generate tensor as functions of its indices
fromIndices :: (Num a) => (String, [Int]) -> (String, [Int]) -> ([Int] -> [Int] -> a) -> Tensor a

-- | Generate tensor composed of other tensors
generate :: (Num a) => (String, [Int]) -> (String, [Int]) -> ([Int] -> [Int] -> Tensor a) -> Tensor a

-- | Generate tensor with all components equal to <tt>v</tt>
const :: (Num a) => (String, [Int]) -> (String, [Int]) -> a -> Tensor a

-- | Generate tensor with random real components with given probability
--   distribution. The tensor is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => (String, [Int]) -> (String, [Int]) -> d -> IO (Tensor Double)

-- | Generate tensor with random real components with given probability
--   distribution and given seed. The tensor is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => (String, [Int]) -> (String, [Int]) -> d -> Int -> m (Tensor Double)

-- | Generate tensor with random integer components with given probability
--   distribution. The tensor is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => (String, [Int]) -> (String, [Int]) -> d -> IO (Tensor Int)

-- | Generate tensor with random integer components with given probability
--   distribution and given seed. The tensor is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => (String, [Int]) -> (String, [Int]) -> d -> Int -> m (Tensor Int)


-- | <ul>
--   <li>This module provides convenient constructors that generates
--   n-forms (tensors with n lower indices with finite or infinite
--   size).</li>
--   <li>Finitely-dimensional n-forms provide much greater performance than
--   infinitely-dimensional</li>
--   </ul>
module Multilinear.NForm

-- | Generate N-form as function of its indices
fromIndices :: (Num a) => String -> [Int] -> ([Int] -> a) -> Tensor a

-- | Generate N-form with all components equal to <tt>v</tt>
const :: (Num a) => String -> [Int] -> a -> Tensor a

-- | Generate n-vector with random real components with given probability
--   distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> [Int] -> d -> IO (Tensor Double)

-- | Generate n-vector with random real components with given probability
--   distribution and given seed. The form is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> [Int] -> d -> Int -> m (Tensor Double)

-- | Generate n-vector with random integer components with given
--   probability distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> [Int] -> d -> IO (Tensor Int)

-- | Generate n-vector with random integer components with given
--   probability distribution and given seed. The form is wrapped in a
--   monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> [Int] -> d -> Int -> m (Tensor Int)

-- | 2-form representing a dot product
dot :: (Num a) => String -> Int -> Tensor a

-- | Tensor representing a cross product (Levi - Civita symbol). It also
--   allows to compute a determinant of square matrix - determinant of
--   matrix <tt>M</tt> is a equal to length of cross product of all columns
--   of <tt>M</tt>
cross :: (Num a) => String -> Int -> Tensor a


-- | <ul>
--   <li>This module provides convenient constructors that generate a
--   n-vector (tensor with n upper indices with finite or infinite
--   size).</li>
--   <li>Finitely-dimensional n-vectors provide much greater performance
--   than infinitely-dimensional</li>
--   </ul>
module Multilinear.NVector

-- | Generate n-vector as function of its indices
fromIndices :: (Num a) => String -> [Int] -> ([Int] -> a) -> Tensor a

-- | Generate n-vector with all components equal to <tt>v</tt>
const :: (Num a) => String -> [Int] -> a -> Tensor a

-- | Generate n-vector with random real components with given probability
--   distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> [Int] -> d -> IO (Tensor Double)

-- | Generate n-vector with random real components with given probability
--   distribution and given seed. The form is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> [Int] -> d -> Int -> m (Tensor Double)

-- | Generate n-vector with random integer components with given
--   probability distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> [Int] -> d -> IO (Tensor Int)

-- | Generate n-vector with random integer components with given
--   probability distribution and given seed. The form is wrapped in a
--   monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> [Int] -> d -> Int -> m (Tensor Int)


-- | <ul>
--   <li>This module provides convenient constructors that generates a
--   matrix (finitely- or infinite-dimensional)</li>
--   <li>Finitely-dimensional matrices provide much greater performance
--   than infinitely-dimensional</li>
--   </ul>
module Multilinear.Matrix

-- | Generate matrix as function of its indices
fromIndices :: (Num a) => String -> Int -> Int -> (Int -> Int -> a) -> Tensor a

-- | Generate matrix with all components equal to <tt>v</tt>
const :: (Num a) => String -> Int -> Int -> a -> Tensor a

-- | Generate matrix with random real components with given probability
--   distribution. The matrix is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> Int -> Int -> d -> IO (Tensor Double)

-- | Generate matrix with random real components with given probability
--   distribution and given seed. The matrix is wrapped in the a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> Int -> Int -> d -> Int -> m (Tensor Double)

-- | Generate matrix with random integer components with given probability
--   distribution. The matrix is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> Int -> Int -> d -> IO (Tensor Int)

-- | Generate matrix with random integer components with given probability
--   distribution. and given seed. The matrix is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> Int -> Int -> d -> Int -> m (Tensor Int)

-- | Read matrix components from CSV file.
fromCSV :: (Num a, NFData a, Serialize a) => String -> String -> Char -> EitherT SomeException IO (Tensor a)

-- | Write matrix to CSV file.
toCSV :: (Num a, NFData a, Serialize a) => Tensor a -> String -> Char -> IO Int


-- | <ul>
--   <li>This module provides convenient constructors that generates a
--   linear functionals</li>
--   <li>Finitely-dimensional functionals provide much greater performance
--   that infinitely-dimensional</li>
--   </ul>
module Multilinear.Form

-- | Generate linear functional as function of indices
fromIndices :: (Num a) => String -> Int -> (Int -> a) -> Tensor a

-- | Generate linear functional with all components equal to some
--   <tt>v</tt>
const :: (Num a) => String -> Int -> a -> Tensor a

-- | Generate linear functional with random real components with given
--   probability distribution. The functional is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> Int -> d -> IO (Tensor Double)

-- | Generate linear functional with random real components with given
--   probability distribution and given seed. The functional is wrapped in
--   a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Double)

-- | Generate linear functional with random integer components with given
--   probability distribution. The functional is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> Int -> d -> IO (Tensor Int)

-- | Generate linear functional with random integer components with given
--   probability distribution and given seed. The functional is wrapped in
--   a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Int)

-- | Generate linear functional as function of indices
fromIndices' :: (Num a) => String -> (Int -> a) -> Tensor a

-- | Generate linear functional with all components equal to some
--   <tt>v</tt>
const' :: (Num a) => String -> a -> Tensor a

-- | Read linear functional components from CSV file. Reads only the first
--   row of the file.
fromCSV :: (Num a, NFData a, Serialize a) => String -> String -> Char -> EitherT SomeException IO (Tensor a)

-- | Write linear functional to CSV file.
toCSV :: (Num a, NFData a, Serialize a) => Tensor a -> String -> Char -> IO Int


-- | <ul>
--   <li>This module contains implementation of tensor defined as nested
--   arrays. Operations performed on this tensors are parallelized to as
--   many cores as availabe.</li>
--   </ul>
module Multilinear.Parallel.Generic

-- | Tensor defined recursively as scalar or list of other tensors
--   
--   <tt>c</tt> is type of a container, <tt>i</tt> is type of index size
--   and <tt>a</tt> is type of tensor elements
data Tensor a

-- | Scalar
Scalar :: a -> Tensor a

-- | value of scalar
[scalarVal] :: Tensor a -> a

-- | Simple, one-dimensional finite tensor
SimpleFinite :: Index -> Vector a -> Tensor a

-- | Finite index <a>Mutltilinear.Index.Finite</a> of tensor
[tensorFiniteIndex] :: Tensor a -> Index
[tensorScalars] :: Tensor a -> Vector a

-- | Finite array of other tensors
FiniteTensor :: Index -> Vector (Tensor a) -> Tensor a

-- | Finite index <a>Mutltilinear.Index.Finite</a> of tensor
[tensorFiniteIndex] :: Tensor a -> Index

-- | Array of tensors on deeper recursion level
[tensorsFinite] :: Tensor a -> Vector (Tensor a)

-- | Infinite list of other tensors
InfiniteTensor :: Index -> [Tensor a] -> Tensor a

-- | Infinite index <a>Mutltilinear.Index.Infinite</a> of tensor
[tensorInfiniteIndex] :: Tensor a -> Index

-- | Infinite list of tensors on deeper recursion level
[tensorsInfinite] :: Tensor a -> [Tensor a]

-- | Operations on tensors may throw an error
Err :: String -> Tensor a

-- | Error message
[errMessage] :: Tensor a -> String

-- | Recursive indexing on list tensor <tt>t ! i = t[i]</tt>
(!) :: Tensor a -> Int -> Tensor a

-- | Merge FiniteTensor of Scalars to SimpleFinite tensor for performance
--   improvement
mergeScalars :: Tensor a -> Tensor a

-- | Return true if tensor is a scalar
isScalar :: Tensor a -> Bool

-- | Return true if tensor is a simple tensor
isSimple :: Tensor a -> Bool

-- | Return True if tensor is a complex tensor
isFiniteTensor :: Tensor a -> Bool

-- | Return True if tensor is a infinite tensor
isInfiniteTensor :: Tensor a -> Bool
dot :: Num a => Tensor a -> Tensor a -> Tensor a

-- | Apply a tensor operator elem by elem and merge scalars to simple
--   tensor at the and
_elemByElem :: Num a => Tensor a -> Tensor a -> (a -> a -> a) -> (Tensor a -> Tensor a -> Tensor a) -> Tensor a
contractionErr :: TIndex -> TIndex -> Tensor a

-- | Return generic tensor index
tensorIndex :: Tensor a -> TIndex
instance GHC.Generics.Generic (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Multilinear.Parallel.Generic.Tensor a)
instance Data.Serialize.Serialize a => Data.Serialize.Serialize (Multilinear.Parallel.Generic.Tensor a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Multilinear.Parallel.Generic.Tensor a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Multilinear.Parallel.Generic.Tensor a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Show.Show a => GHC.Show.Show (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Base.Functor Multilinear.Parallel.Generic.Tensor
instance GHC.Classes.Ord a => GHC.Classes.Ord (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Num.Num a => GHC.Base.Monoid (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Num.Num a => GHC.Num.Num (Multilinear.Parallel.Generic.Tensor a)
instance (GHC.Num.Num a, Data.Bits.Bits a) => Data.Bits.Bits (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Float.Floating a => GHC.Float.Floating (Multilinear.Parallel.Generic.Tensor a)
instance GHC.Num.Num a => Multilinear.Multilinear Multilinear.Parallel.Generic.Tensor a
instance GHC.Num.Num a => Multilinear.Accessible Multilinear.Parallel.Generic.Tensor a


-- | <ul>
--   <li>This module provides convenient constructors that generates a
--   parallelizable linear functionals</li>
--   <li>Finitely-dimensional functionals provide much greater performance
--   that infinitely-dimensional</li>
--   </ul>
module Multilinear.Parallel.Form

-- | Generate linear functional as function of indices
fromIndices :: (Num a) => String -> Int -> (Int -> a) -> Tensor a

-- | Generate linear functional with all components equal to some
--   <tt>v</tt>
const :: (Num a) => String -> Int -> a -> Tensor a

-- | Generate linear functional with random real components with given
--   probability distribution. The functional is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> Int -> d -> IO (Tensor Double)

-- | Generate linear functional with random real components with given
--   probability distribution and given seed. The functional is wrapped in
--   a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Double)

-- | Generate linear functional with random integer components with given
--   probability distribution. The functional is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> Int -> d -> IO (Tensor Int)

-- | Generate linear functional with random integer components with given
--   probability distribution and given seed. The functional is wrapped in
--   a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Int)

-- | Generate linear functional as function of indices
fromIndices' :: (Num a) => String -> (Int -> a) -> Tensor a

-- | Generate linear functional with all components equal to some
--   <tt>v</tt>
const' :: (Num a) => String -> a -> Tensor a

-- | Read linear functional components from CSV file. Reads only the first
--   row of the file.
fromCSV :: (Num a, NFData a, Serialize a) => String -> String -> Char -> EitherT SomeException IO (Tensor a)

-- | Write linear functional to CSV file.
toCSV :: (Num a, NFData a, Serialize a) => Tensor a -> String -> Char -> IO Int


-- | <ul>
--   <li>This module provides convenient constructors that generate a
--   parallelizable n-vectors (tensors with n upper indices with finite or
--   infinite size).</li>
--   <li>Finitely-dimensional n-vectors provide much greater performance
--   than infinitely-dimensional</li>
--   </ul>
module Multilinear.Parallel.NVector

-- | Generate n-vector as function of its indices
fromIndices :: (Num a) => String -> [Int] -> ([Int] -> a) -> Tensor a

-- | Generate n-vector with all components equal to <tt>v</tt>
const :: (Num a) => String -> [Int] -> a -> Tensor a

-- | Generate n-vector with random real components with given probability
--   distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> [Int] -> d -> IO (Tensor Double)

-- | Generate n-vector with random real components with given probability
--   distribution and given seed. The form is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, Integral i2, PrimMonad m) => String -> [Int] -> d -> i2 -> m (Tensor Double)

-- | Generate n-vector with random integer components with given
--   probability distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> [Int] -> d -> IO (Tensor Int)

-- | Generate n-vector with random integer components with given
--   probability distribution and given seed. The form is wrapped in a
--   monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, Integral i2, PrimMonad m) => String -> [Int] -> d -> i2 -> m (Tensor Int)


-- | <ul>
--   <li>This module provides convenient constructors that generate a
--   arbitrary, parallelizable tensors of finite or infinite size.</li>
--   <li>Finitely-dimensional tensors provide much greater performance than
--   inifitely-dimensional</li>
--   </ul>
module Multilinear.Parallel.Tensor

-- | Generate tensor as functions of its indices
fromIndices :: (Num a) => (String, [Int]) -> (String, [Int]) -> ([Int] -> [Int] -> a) -> Tensor a

-- | Generate tensor with all components equal to <tt>v</tt>
const :: (Num a) => (String, [Int]) -> (String, [Int]) -> a -> Tensor a

-- | Generate tensor with random real components with given probability
--   distribution. The tensor is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => (String, [Int]) -> (String, [Int]) -> d -> IO (Tensor Double)

-- | Generate tensor with random real components with given probability
--   distribution and given seed. The tensor is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => (String, [Int]) -> (String, [Int]) -> d -> Int -> m (Tensor Double)

-- | Generate tensor with random integer components with given probability
--   distribution. The tensor is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => (String, [Int]) -> (String, [Int]) -> d -> IO (Tensor Int)

-- | Generate tensor with random integer components with given probability
--   distribution and given seed. The tensor is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => (String, [Int]) -> (String, [Int]) -> d -> Int -> m (Tensor Int)


-- | <ul>
--   <li>This module provides convenient constructors that generates
--   parallelizable n-forms (tensors with n lower indices of finite or
--   infinite size).</li>
--   <li>Finitely-dimensional n-forms provide much greater performance than
--   infinitely-dimensional</li>
--   </ul>
module Multilinear.Parallel.NForm

-- | Generate N-form as function of its indices
fromIndices :: (Num a) => String -> [Int] -> ([Int] -> a) -> Tensor a

-- | Generate N-form with all components equal to <tt>v</tt>
const :: (Num a) => String -> [Int] -> a -> Tensor a

-- | Generate n-vector with random real components with given probability
--   distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> [Int] -> d -> IO (Tensor Double)

-- | Generate n-vector with random real components with given probability
--   distribution and given seed. The form is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, Integral i2, PrimMonad m) => String -> [Int] -> d -> i2 -> m (Tensor Double)

-- | Generate n-vector with random integer components with given
--   probability distribution. The n-vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> [Int] -> d -> IO (Tensor Int)

-- | Generate n-vector with random integer components with given
--   probability distribution and given seed. The form is wrapped in a
--   monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, Integral i2, PrimMonad m) => String -> [Int] -> d -> i2 -> m (Tensor Int)

-- | 2-form representing a dot product
dot :: (Num a) => String -> Int -> Tensor a

-- | Tensor representing a cross product (Levi - Civita symbol). It also
--   allows to compute a determinant of square matrix - determinant of
--   matrix <tt>M</tt> is a equal to length of cross product of all columns
--   of <tt>M</tt>
cross :: (Num a) => String -> Int -> Tensor a


-- | <ul>
--   <li>This module provides convenient constructors that generates a
--   parallelizable matrices (finitely- or infinitely-dimensional)</li>
--   <li>Finitely-dimensional matrices provide much greater performance
--   than infinitely-dimensional</li>
--   </ul>
module Multilinear.Parallel.Matrix

-- | Generate matrix as function of its indices
fromIndices :: (Num a) => String -> Int -> Int -> (Int -> Int -> a) -> Tensor a

-- | Generate matrix with all components equal to <tt>v</tt>
const :: (Num a) => String -> Int -> Int -> a -> Tensor a

-- | Generate matrix with random real components with given probability
--   distribution. The matrix is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> Int -> Int -> d -> IO (Tensor Double)

-- | Generate matrix with random real components with given probability
--   distribution and given seed. The matrix is wrapped in the a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> Int -> Int -> d -> Int -> m (Tensor Double)

-- | Generate matrix with random integer components with given probability
--   distribution. The matrix is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> Int -> Int -> d -> IO (Tensor Int)

-- | Generate matrix with random integer components with given probability
--   distribution. and given seed. The matrix is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> Int -> Int -> d -> Int -> m (Tensor Int)

-- | Read matrix components from CSV file.
fromCSV :: (Num a, NFData a, Serialize a) => String -> String -> Char -> EitherT SomeException IO (Tensor a)

-- | Write matrix to CSV file.
toCSV :: (Num a, NFData a, Serialize a) => Tensor a -> String -> Char -> IO Int


-- | <ul>
--   <li>This module provides convenient constructors that generates a
--   vector (tensor with one upper index) in array (<a>Data.Vector</a>)
--   implementation</li>
--   <li>Finitely-dimensional vectors provide much greater performance than
--   infinitely-dimensional</li>
--   </ul>
module Multilinear.Parallel.Vector

-- | Generate vector as function of indices
fromIndices :: (Num a) => String -> Int -> (Int -> a) -> Tensor a

-- | Generate vector with all components equal to some <tt>v</tt>
const :: (Num a) => String -> Int -> a -> Tensor a

-- | Generate vector with random real components with given probability
--   distribution. The vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> Int -> d -> IO (Tensor Double)

-- | Generate vector with random real components with given probability
--   distribution and given seed. The vector is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Double)

-- | Generate vector with random integer components with given probability
--   distribution. The vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> Int -> d -> IO (Tensor Int)

-- | Generate vector with random integer components with given probability
--   distribution and given seed. The vector is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Int)

-- | Read vector components from CSV file. Reads only the first row of the
--   file.
fromCSV :: (Num a, NFData a, Serialize a) => String -> String -> Char -> EitherT SomeException IO (Tensor a)

-- | Write vector to CSV file.
toCSV :: (Num a, NFData a, Serialize a) => Tensor a -> String -> Char -> IO Int


-- | <ul>
--   <li>This module provides convenient constructors that generates a
--   vector (tensor with one upper index) of finite or infinite size.</li>
--   <li>Finitely-dimensional vectors provide much greater performance than
--   infinitely-dimensional</li>
--   </ul>
module Multilinear.Vector

-- | Generate vector as function of indices
fromIndices :: (Num a) => String -> Int -> (Int -> a) -> Tensor a

-- | Generate vector with all components equal to some <tt>v</tt>
const :: (Num a) => String -> Int -> a -> Tensor a

-- | Generate vector with random real components with given probability
--   distribution. The vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDouble :: (ContGen d) => String -> Int -> d -> IO (Tensor Double)

-- | Generate vector with random real components with given probability
--   distribution and given seed. The vector is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Beta : <a>Statistics.Distribution.BetaDistribution</a></li>
--   <li>Cauchy : <a>Statistics.Distribution.CauchyLorentz</a></li>
--   <li>Chi-squared : <a>Statistics.Distribution.ChiSquared</a></li>
--   <li>Exponential : <a>Statistics.Distribution.Exponential</a></li>
--   <li>Gamma : <a>Statistics.Distribution.Gamma</a></li>
--   <li>Normal : <a>Statistics.Distribution.Normal</a></li>
--   <li>StudentT : <a>Statistics.Distribution.StudentT</a></li>
--   <li>Uniform : <a>Statistics.Distribution.Uniform</a></li>
--   <li>F : <a>Statistics.Distribution.FDistribution</a></li>
--   <li>Laplace : <a>Statistics.Distribution.Laplace</a></li>
--   </ul>
randomDoubleSeed :: (ContGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Double)

-- | Generate vector with random integer components with given probability
--   distribution. The vector is wrapped in the IO monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomInt :: (DiscreteGen d) => String -> Int -> d -> IO (Tensor Int)

-- | Generate vector with random integer components with given probability
--   distribution and given seed. The vector is wrapped in a monad.
--   
--   Available probability distributions:
--   
--   <ul>
--   <li>Binomial : <a>Statistics.Distribution.Binomial</a></li>
--   <li>Poisson : <a>Statistics.Distribution.Poisson</a></li>
--   <li>Geometric : <a>Statistics.Distribution.Geometric</a></li>
--   <li>Hypergeometric: <a>Statistics.Distribution.Hypergeometric</a></li>
--   </ul>
randomIntSeed :: (DiscreteGen d, PrimMonad m) => String -> Int -> d -> Int -> m (Tensor Int)

-- | Read vector components from CSV file. Reads only the first row of the
--   file.
fromCSV :: (Num a, NFData a, Serialize a) => String -> String -> Char -> EitherT SomeException IO (Tensor a)

-- | Write vector to CSV file.
toCSV :: (Num a, NFData a, Serialize a) => Tensor a -> String -> Char -> IO Int


-- | Defines main tyclasses to deal with multilinear algebra and re-exports
--   content of other library modules.
module Library
